import{_ as t,c as a,o as r,ae as o}from"./chunks/framework.BQlYxExx.js";const g=JSON.parse('{"title":"Architecture","description":"","frontmatter":{},"headers":[],"relativePath":"guide/architecture.md","filePath":"guide/architecture.md"}'),n={name:"guide/architecture.md"};function i(s,e,l,c,h,d){return r(),a("div",null,[...e[0]||(e[0]=[o('<h1 id="architecture" tabindex="-1">Architecture <a class="header-anchor" href="#architecture" aria-label="Permalink to &quot;Architecture&quot;">​</a></h1><p>Zentro is designed as a modular, high-performance API Gateway. This section explains the core components and the lifecycle of a request as it flows through the system.</p><h2 id="core-components" tabindex="-1">Core Components <a class="header-anchor" href="#core-components" aria-label="Permalink to &quot;Core Components&quot;">​</a></h2><h3 id="_1-router" tabindex="-1">1. Router <a class="header-anchor" href="#_1-router" aria-label="Permalink to &quot;1. Router&quot;">​</a></h3><p>The Router is responsible for matching incoming HTTP requests to configured routes. It uses a high-performance matching algorithm (powered by <code>chi</code>) to identify the correct route based on:</p><ul><li><strong>Path Prefix</strong>: e.g., <code>/api/v1</code></li><li><strong>HTTP Method</strong>: e.g., <code>GET</code>, <code>POST</code></li><li><strong>Host Header</strong>: (Optional)</li></ul><h3 id="_2-filter-chain" tabindex="-1">2. Filter Chain <a class="header-anchor" href="#_2-filter-chain" aria-label="Permalink to &quot;2. Filter Chain&quot;">​</a></h3><p>Once a route is matched, the request passes through a chain of filters. Filters are middleware components that can:</p><ul><li><strong>Pre-process</strong>: Modify the request before it reaches the upstream (e.g., Authentication, Rate Limiting, Header Injection).</li><li><strong>Post-process</strong>: Modify the response before it reaches the client (e.g., Header Removal, Body Transformation).</li></ul><h3 id="_3-load-balancer" tabindex="-1">3. Load Balancer <a class="header-anchor" href="#_3-load-balancer" aria-label="Permalink to &quot;3. Load Balancer&quot;">​</a></h3><p>If a route has multiple upstream services configured, the Load Balancer determines which instance should receive the request.</p><ul><li><strong>Strategy</strong>: Currently supports <strong>Round-Robin</strong>.</li><li><strong>Health Checks</strong>: Passive health checking detects failures. If an upstream returns an error (502/503) or fails to connect, it is marked as unhealthy for a cooldown period.</li></ul><h3 id="_4-proxy" tabindex="-1">4. Proxy <a class="header-anchor" href="#_4-proxy" aria-label="Permalink to &quot;4. Proxy&quot;">​</a></h3><p>The Proxy component handles the actual forwarding of the request to the selected upstream service. It manages connection pooling and timeouts.</p><h2 id="request-lifecycle" tabindex="-1">Request Lifecycle <a class="header-anchor" href="#request-lifecycle" aria-label="Permalink to &quot;Request Lifecycle&quot;">​</a></h2><ol><li><strong>Incoming Request</strong>: A client sends a request to Zentro (e.g., <code>GET /users/123</code>).</li><li><strong>Routing</strong>: Zentro checks <code>routes.json</code> to find a matching route.</li><li><strong>Authentication (Optional)</strong>: If configured, the Auth filter verifies credentials (Bearer Token, API Key, etc.).</li><li><strong>Request Filters</strong>: Filters like <code>RateLimit</code>, <code>AddHeader</code>, or <code>RewritePath</code> are executed in order.</li><li><strong>Load Balancing</strong>: The Load Balancer selects a healthy upstream target (e.g., <code>http://users-service-1:8080</code>).</li><li><strong>Proxying</strong>: The request is sent to the upstream service.</li><li><strong>Response Filters</strong>: The upstream response is intercepted. Filters like <code>ModifyResponseBody</code> or <code>RemoveHeader</code> are applied.</li><li><strong>Final Response</strong>: The processed response is sent back to the client.</li></ol><h2 id="load-balancing-fault-tolerance" tabindex="-1">Load Balancing &amp; Fault Tolerance <a class="header-anchor" href="#load-balancing-fault-tolerance" aria-label="Permalink to &quot;Load Balancing &amp; Fault Tolerance&quot;">​</a></h2><p>Zentro implements a <strong>Passive Health Check</strong> mechanism:</p><ul><li><strong>Failure Detection</strong>: If a request to an upstream fails (network error or 5xx), the failure count for that target is incremented.</li><li><strong>Circuit Breaking</strong>: When failures exceed the <code>failureCount</code> threshold (default: 3), the target is marked <strong>Unhealthy</strong>.</li><li><strong>Recovery</strong>: After the <code>cooldown</code> period (default: 10s), the target enters a <strong>Test</strong> state. The next request is allowed through; if successful, the target is marked <strong>Healthy</strong> again.</li></ul><h2 id="management-api" tabindex="-1">Management API <a class="header-anchor" href="#management-api" aria-label="Permalink to &quot;Management API&quot;">​</a></h2><p>The Management API runs on a separate port (default: <code>8081</code>) and provides a REST interface to:</p><ul><li>Dynamically update configuration (hot-reload).</li><li>View real-time traffic logs.</li><li>Manage consumers and credentials.</li></ul>',22)])])}const p=t(n,[["render",i]]);export{g as __pageData,p as default};
